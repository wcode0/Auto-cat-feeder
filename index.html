<div>Teachable Machine Image Model</div>
<button type="button" onclick="init()">Start</button>
<div id="webcam-container"></div>
<div id="label-container"></div>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
<script type="text/javascript">

  const URL = "./model/";

  let model, webcam, labelContainer, maxPredictions;
  let flashlightActive = false;

  // Check if flashlight should be on based on time (5pm to 7pm)
  function checkTimeAndSetFlashlight() {
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();
    const currentTime = currentHour * 60 + currentMinute; // convert to minutes
    const fivePmTime = 17* 60; // 5pm in minutes
    const sevenPmTime = 19 * 60; // 7pm in minutes

    if (currentTime >= fivePmTime && currentTime < sevenPmTime && !flashlightActive) {
      enableFlashlight();
    } else if ((currentTime < fivePmTime || currentTime >= sevenPmTime) && flashlightActive) {
      disableFlashlight();
    }
  }

  function enableFlashlight() {
    flashlightActive = true;
    console.log("Flashlight turned ON");
    activateTorch();
  }

  function disableFlashlight() {
    flashlightActive = false;
    console.log("Flashlight turned OFF");
    deactivateTorch();
  }

  async function activateTorch() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "environment" }
      });
      const track = stream.getVideoTracks()[0];
      const capabilities = track.getCapabilities();
      if (capabilities.torch) {
        await track.applyConstraints({ torch: true });
      }
    } catch (error) {
      console.log("Torch API not available:", error);
    }
  }

  async function deactivateTorch() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "environment" }
      });
      const track = stream.getVideoTracks()[0];
      const capabilities = track.getCapabilities();
      if (capabilities.torch) {
        await track.applyConstraints({ torch: false });
      }
    } catch (error) {
      console.log("Torch API not available:", error);
    }
  }

  async function init() {
    const modelURL = URL + "model.json";
    const metadataURL = URL + "metadata.json";

  
    model = await tmImage.load(modelURL, metadataURL);
    maxPredictions = model.getTotalClasses();

    // Convenience function to setup a webcam
    const flip = false; // optional for rear camera
    webcam = new tmImage.Webcam(200, 200, flip);
    await webcam.setup({ facingMode: "environment" }); // rear camera
    await webcam.play();

    window.requestAnimationFrame(loop);

    // append elements to the DOM
    document.getElementById("webcam-container").appendChild(webcam.canvas);
    labelContainer = document.getElementById("label-container");
    for (let i = 0; i < maxPredictions; i++) {
      // and class labels
      labelContainer.appendChild(document.createElement("div"));
    }

    // Check time and set flashlight accordingly
    checkTimeAndSetFlashlight();
    // Check time every minute
    setInterval(checkTimeAndSetFlashlight, 60000);
  }

  async function loop() {
    webcam.update(); // update the webcam frame
    await predict();
    window.requestAnimationFrame(loop);
  }

  // run the webcam image through the image model
 async function predict() {
  const prediction = await model.predict(webcam.canvas);
  let probs = {};
  for (let i = 0; i < maxPredictions; i++) {
    const classPrediction =
      prediction[i].className + ": " + prediction[i].probability.toFixed(2);
    labelContainer.childNodes[i].innerHTML = classPrediction;
    probs[prediction[i].className] = prediction[i].probability.toFixed(2);
  }

  // send probabilities to ESP32
  fetch(`http://192.168.68.56/probabilities?catA=${probs["Cat A"]}&catB=${probs["Cat B"]}`)
    .catch(err => console.log("ESP32 not reachable", err));
}


</script>
